{"parsed":{"_path":"/article/lc_62","_dir":"article","_draft":false,"_partial":false,"_locale":"en","_empty":false,"title":"Leetcode No.62 Unique Paths","description":"The solution to the leetcode no.62 Unique Paths. Medium level.","excerpt":{"type":"root","children":[{"type":"element","tag":"h2","props":{"id":"question"},"children":[{"type":"text","value":"Question"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"问总共有多少条不同的路径？"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"robot_maze","src":"/img/leetcode/robot_maze.png"},"children":[]}]},{"type":"element","tag":"code","props":{"code":"输入：m = 3, n = 2\n输出：3\n\n-> m\n[0][ ][ ]\n[ ][ ][x]\n"},"children":[{"type":"element","tag":"pre","props":{},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"输入：m = 3, n = 2\n输出：3\n\n-> m\n[0][ ][ ]\n[ ][ ][x]\n"}]}]}]},{"type":"element","tag":"h2","props":{"id":"solution"},"children":[{"type":"text","value":"Solution"}]},{"type":"element","tag":"h3","props":{"id":"a-dfs"},"children":[{"type":"text","value":"a. DFS"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"My first thought was using "},{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"DFS"}]},{"type":"text","value":" to solve this problem."}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Every step has two directions: "},{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"x"}]},{"type":"text","value":" or "},{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"y"}]},{"type":"text","value":"."}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"To reach the destination, the robot's "},{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"x"}]},{"type":"text","value":" should be less than "},{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"m"}]},{"type":"text","value":" and "},{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"y"}]},{"type":"text","value":" should be less than "},{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"n"}]},{"type":"text","value":"."}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"When "},{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"x"}]},{"type":"text","value":" is equal to "},{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"m"}]},{"type":"text","value":" and "},{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"y"}]},{"type":"text","value":" is equal to "},{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"n"}]},{"type":"text","value":", the robot reaches the destination."}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Here is the code:"}]},{"type":"element","tag":"code","props":{"code":"def uniquePaths(m: int, n: int) -> int:\n    x, y = 1, 1\n    ans = [0]\n\n    def dfs(x, y, m, n):\n        if x == m and y == n:\n            ans[0] += 1\n            return 0\n        if x < m:\n            dfs(x+1, y, m, n)\n        if y < n:\n            dfs(x, y+1, m, n)\n    dfs(x, y, m, n)\n    return ans[0]\n","language":"python"},"children":[{"type":"element","tag":"pre","props":{},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"def uniquePaths(m: int, n: int) -> int:\n    x, y = 1, 1\n    ans = [0]\n\n    def dfs(x, y, m, n):\n        if x == m and y == n:\n            ans[0] += 1\n            return 0\n        if x < m:\n            dfs(x+1, y, m, n)\n        if y < n:\n            dfs(x, y+1, m, n)\n    dfs(x, y, m, n)\n    return ans[0]\n"}]}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Not surprisingly, this method will time out.\nWe need another algorithm to scale down the Time complexity."}]},{"type":"element","tag":"h3","props":{"id":"b-dp-dynamic-programming"},"children":[{"type":"text","value":"b. DP (Dynamic Programming)"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"DP is "},{"type":"element","tag":"em","props":{},"children":[{"type":"text","value":"Divide-and-Conque (D&C)"}]},{"type":"text","value":" with "},{"type":"element","tag":"em","props":{},"children":[{"type":"text","value":"Memorization"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Take a closer look to is problem, I found that "},{"type":"element","tag":"em","props":{},"children":[{"type":"text","value":"divide-and-conque (D&C)"}]},{"type":"text","value":" algorithm is really suitable.\nThe problem "},{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"f(m, n)"}]},{"type":"text","value":" could be divided into two parts: "},{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"f(m, n-1)"}]},{"type":"text","value":" and "},{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"f(m-1, n)"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Additional, there is only "},{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"1"}]},{"type":"text","value":" way if "},{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"m"}]},{"type":"text","value":" is equal to 1 or "},{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"n"}]},{"type":"text","value":" is equal to 1."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"So we have the following "},{"type":"element","tag":"em","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"Recurrence"}]}]},{"type":"text","value":":"}]},{"type":"element","tag":"p","props":{"className":["text-center","code-family"]},"children":[{"type":"text","value":"f(m,n) = 1, if m = 1 or n = 1"}]},{"type":"element","tag":"p","props":{"className":["text-center","code-family"]},"children":[{"type":"text","value":"f(m,n) = f(m-1, n) + f(m, n-1)"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Implementing the algorithm with python3."}]},{"type":"element","tag":"code","props":{"code":"def uniquePaths(m: int, n: int) -> int:\n    dp = [[1]*n] + [[1]+[0]*(n-1) for _ in range(m-1)]  # init lookup table\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = dp[i-1][j] + dp[i][j-1]\n    return dp[m-1][n-1]\n","language":"python"},"children":[{"type":"element","tag":"pre","props":{},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"def uniquePaths(m: int, n: int) -> int:\n    dp = [[1]*n] + [[1]+[0]*(n-1) for _ in range(m-1)]  # init lookup table\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = dp[i-1][j] + dp[i][j-1]\n    return dp[m-1][n-1]\n"}]}]}]}]},"date":"2022/11/12","image":{"src":"/img/leetcode/no62_cover.jpg","alt":"no62_cover"},"tags":["algorithm","dynamic programming","dfs"],"body":{"type":"root","children":[{"type":"element","tag":"h2","props":{"id":"question"},"children":[{"type":"text","value":"Question"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"问总共有多少条不同的路径？"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"robot_maze","src":"/img/leetcode/robot_maze.png"},"children":[]}]},{"type":"element","tag":"code","props":{"code":"输入：m = 3, n = 2\n输出：3\n\n-> m\n[0][ ][ ]\n[ ][ ][x]\n"},"children":[{"type":"element","tag":"pre","props":{},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"输入：m = 3, n = 2\n输出：3\n\n-> m\n[0][ ][ ]\n[ ][ ][x]\n"}]}]}]},{"type":"element","tag":"h2","props":{"id":"solution"},"children":[{"type":"text","value":"Solution"}]},{"type":"element","tag":"h3","props":{"id":"a-dfs"},"children":[{"type":"text","value":"a. DFS"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"My first thought was using "},{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"DFS"}]},{"type":"text","value":" to solve this problem."}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Every step has two directions: "},{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"x"}]},{"type":"text","value":" or "},{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"y"}]},{"type":"text","value":"."}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"To reach the destination, the robot's "},{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"x"}]},{"type":"text","value":" should be less than "},{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"m"}]},{"type":"text","value":" and "},{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"y"}]},{"type":"text","value":" should be less than "},{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"n"}]},{"type":"text","value":"."}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"When "},{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"x"}]},{"type":"text","value":" is equal to "},{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"m"}]},{"type":"text","value":" and "},{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"y"}]},{"type":"text","value":" is equal to "},{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"n"}]},{"type":"text","value":", the robot reaches the destination."}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Here is the code:"}]},{"type":"element","tag":"code","props":{"code":"def uniquePaths(m: int, n: int) -> int:\n    x, y = 1, 1\n    ans = [0]\n\n    def dfs(x, y, m, n):\n        if x == m and y == n:\n            ans[0] += 1\n            return 0\n        if x < m:\n            dfs(x+1, y, m, n)\n        if y < n:\n            dfs(x, y+1, m, n)\n    dfs(x, y, m, n)\n    return ans[0]\n","language":"python"},"children":[{"type":"element","tag":"pre","props":{},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"def uniquePaths(m: int, n: int) -> int:\n    x, y = 1, 1\n    ans = [0]\n\n    def dfs(x, y, m, n):\n        if x == m and y == n:\n            ans[0] += 1\n            return 0\n        if x < m:\n            dfs(x+1, y, m, n)\n        if y < n:\n            dfs(x, y+1, m, n)\n    dfs(x, y, m, n)\n    return ans[0]\n"}]}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Not surprisingly, this method will time out.\nWe need another algorithm to scale down the Time complexity."}]},{"type":"element","tag":"h3","props":{"id":"b-dp-dynamic-programming"},"children":[{"type":"text","value":"b. DP (Dynamic Programming)"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"DP is "},{"type":"element","tag":"em","props":{},"children":[{"type":"text","value":"Divide-and-Conque (D&C)"}]},{"type":"text","value":" with "},{"type":"element","tag":"em","props":{},"children":[{"type":"text","value":"Memorization"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Take a closer look to is problem, I found that "},{"type":"element","tag":"em","props":{},"children":[{"type":"text","value":"divide-and-conque (D&C)"}]},{"type":"text","value":" algorithm is really suitable.\nThe problem "},{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"f(m, n)"}]},{"type":"text","value":" could be divided into two parts: "},{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"f(m, n-1)"}]},{"type":"text","value":" and "},{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"f(m-1, n)"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Additional, there is only "},{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"1"}]},{"type":"text","value":" way if "},{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"m"}]},{"type":"text","value":" is equal to 1 or "},{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"n"}]},{"type":"text","value":" is equal to 1."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"So we have the following "},{"type":"element","tag":"em","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"Recurrence"}]}]},{"type":"text","value":":"}]},{"type":"element","tag":"p","props":{"className":["text-center","code-family"]},"children":[{"type":"text","value":"f(m,n) = 1, if m = 1 or n = 1"}]},{"type":"element","tag":"p","props":{"className":["text-center","code-family"]},"children":[{"type":"text","value":"f(m,n) = f(m-1, n) + f(m, n-1)"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Implementing the algorithm with python3."}]},{"type":"element","tag":"code","props":{"code":"def uniquePaths(m: int, n: int) -> int:\n    dp = [[1]*n] + [[1]+[0]*(n-1) for _ in range(m-1)]  # init lookup table\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = dp[i-1][j] + dp[i][j-1]\n    return dp[m-1][n-1]\n","language":"python"},"children":[{"type":"element","tag":"pre","props":{},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"def uniquePaths(m: int, n: int) -> int:\n    dp = [[1]*n] + [[1]+[0]*(n-1) for _ in range(m-1)]  # init lookup table\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = dp[i-1][j] + dp[i][j-1]\n    return dp[m-1][n-1]\n"}]}]}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[{"id":"question","depth":2,"text":"Question"},{"id":"solution","depth":2,"text":"Solution","children":[{"id":"a-dfs","depth":3,"text":"a. DFS"},{"id":"b-dp-dynamic-programming","depth":3,"text":"b. DP (Dynamic Programming)"}]}]}},"_type":"markdown","_id":"content:article:8.lc_62.md","_source":"content","_file":"article/8.lc_62.md","_extension":"md"},"hash":"0WZX4AL2JB"}