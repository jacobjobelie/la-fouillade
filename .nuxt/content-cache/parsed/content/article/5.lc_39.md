{"parsed":{"_path":"/article/lc_39","_dir":"article","_draft":false,"_partial":false,"_locale":"en","_empty":false,"title":"Leetcode No.39 Combination Sum","description":"The dfs solution to leetcode no. 39. Medium level.","excerpt":{"type":"root","children":[{"type":"element","tag":"h2","props":{"id":"question"},"children":[{"type":"text","value":"Question"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"给你一个 无重复元素 的整数数组 candidates 和一个目标整数 target ，找出 candidates 中可以使数字和为目标数 target 的 所有 不同组合 ，并以列表形式返回。你可以按 任意顺序 返回这些组合。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"candidates 中的 同一个 数字可以 无限制重复被选取 。如果至少一个数字的被选数量不同，则两种组合是不同的。 "}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"对于给定的输入，保证和为 target 的不同组合数少于 150 个。"}]},{"type":"element","tag":"code","props":{"code":"输入：candidates = [2,3,6,7], target = 7\n输出：[[2,2,3],[7]]\n\n输入: candidates = [2,3,5], target = 8\n输出: [[2,2,2,2],[2,3,3],[3,5]]\n","language":"python"},"children":[{"type":"element","tag":"pre","props":{},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"输入：candidates = [2,3,6,7], target = 7\n输出：[[2,2,3],[7]]\n\n输入: candidates = [2,3,5], target = 8\n输出: [[2,2,2,2],[2,3,3],[3,5]]\n"}]}]}]},{"type":"element","tag":"h2","props":{"id":"solution"},"children":[{"type":"text","value":"Solution"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"第一反应是使用 "},{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"dfs"}]},{"type":"text","value":" 搜索算法。因为可以重复使用元素，所以每个节点的子节点是 "},{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"candidates"}]},{"type":"text","value":" 中的各个元素。\n使用回溯法编写脚本如下："}]},{"type":"element","tag":"blockquote","props":{},"children":[{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"The first thought is using "},{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"dfs"}]},{"type":"text","value":" search algorithm.\nAs we can use the elements of "},{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"candidates"}]},{"type":"text","value":" repetitively,\nthe children node of each node would be all element of the "},{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"candidates"}]},{"type":"text","value":".\nApplying the "},{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"dfs"}]},{"type":"text","value":" by recursively traversing."}]}]},{"type":"element","tag":"code","props":{"code":"def combinationSum(candidates: List[int], target: int) -> List[List[int]]:\n    ans = []\n\n    def dfs(candidates, t, l):\n        for c in candidates:\n            if c == t:\n                ans.append(l+[c])\n            elif c > t:\n                continue\n            else:\n                dfs(candidates, t-c, l+[c])\n\n    dfs(candidates, target, [])\n    return ans\n","language":"python"},"children":[{"type":"element","tag":"pre","props":{},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"def combinationSum(candidates: List[int], target: int) -> List[List[int]]:\n    ans = []\n\n    def dfs(candidates, t, l):\n        for c in candidates:\n            if c == t:\n                ans.append(l+[c])\n            elif c > t:\n                continue\n            else:\n                dfs(candidates, t-c, l+[c])\n\n    dfs(candidates, target, [])\n    return ans\n"}]}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"此时的结果为:"}]},{"type":"element","tag":"code","props":{"code":"print(combinationSum([2, 3, 6, 7], 7))\n[[2, 2, 3], [2, 3, 2], [3, 2, 2], [7]]\n"},"children":[{"type":"element","tag":"pre","props":{},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"print(combinationSum([2, 3, 6, 7], 7))\n[[2, 2, 3], [2, 3, 2], [3, 2, 2], [7]]\n"}]}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"并发现有重复的答案，通过观察发现有以下规律："}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"向下搜索时，总是从左端开始，也就是小的数字开始"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"重复的现象出现于：先到达值较大的节点，然后搜索值小的节点。然而这种情况必然导致重复，因为我们每次都是从值小的节点开始搜索的。"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"因此，为了去重我们需要这样做：每次到达某节点时，若该节点的值比 "},{"type":"element","tag":"em","props":{},"children":[{"type":"text","value":"遍历过的最大值"}]},{"type":"text","value":" 小，\n那么我们有理由认为这将导致重复的结果，因此只需添加一个判断即可："}]},{"type":"element","tag":"code","props":{"code":"def combinationSum(candidates: List[int], target: int) -> List[List[int]]:\n    ans = []\n\n    def dfs(candidates, t, l):\n        for c in candidates:\n            if len(l) and c < max(l):\n                continue\n            if c == t:\n                ans.append(l+[c])\n            elif c > t:\n                continue\n            else:\n                dfs(candidates, t-c, l+[c])\n\n    dfs(candidates, target, [])\n    return ans\n","highlights":[6,7],"language":"python"},"children":[{"type":"element","tag":"pre","props":{},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"def combinationSum(candidates: List[int], target: int) -> List[List[int]]:\n    ans = []\n\n    def dfs(candidates, t, l):\n        for c in candidates:\n            if len(l) and c < max(l):\n                continue\n            if c == t:\n                ans.append(l+[c])\n            elif c > t:\n                continue\n            else:\n                dfs(candidates, t-c, l+[c])\n\n    dfs(candidates, target, [])\n    return ans\n"}]}]}]}]},"date":"2022/11/07","image":{"src":"/img/leetcode/no39_cover.jpg","alt":"no39_cover"},"tags":["algorithm","dfs"],"body":{"type":"root","children":[{"type":"element","tag":"h2","props":{"id":"question"},"children":[{"type":"text","value":"Question"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"给你一个 无重复元素 的整数数组 candidates 和一个目标整数 target ，找出 candidates 中可以使数字和为目标数 target 的 所有 不同组合 ，并以列表形式返回。你可以按 任意顺序 返回这些组合。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"candidates 中的 同一个 数字可以 无限制重复被选取 。如果至少一个数字的被选数量不同，则两种组合是不同的。 "}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"对于给定的输入，保证和为 target 的不同组合数少于 150 个。"}]},{"type":"element","tag":"code","props":{"code":"输入：candidates = [2,3,6,7], target = 7\n输出：[[2,2,3],[7]]\n\n输入: candidates = [2,3,5], target = 8\n输出: [[2,2,2,2],[2,3,3],[3,5]]\n","language":"python"},"children":[{"type":"element","tag":"pre","props":{},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"输入：candidates = [2,3,6,7], target = 7\n输出：[[2,2,3],[7]]\n\n输入: candidates = [2,3,5], target = 8\n输出: [[2,2,2,2],[2,3,3],[3,5]]\n"}]}]}]},{"type":"element","tag":"h2","props":{"id":"solution"},"children":[{"type":"text","value":"Solution"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"第一反应是使用 "},{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"dfs"}]},{"type":"text","value":" 搜索算法。因为可以重复使用元素，所以每个节点的子节点是 "},{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"candidates"}]},{"type":"text","value":" 中的各个元素。\n使用回溯法编写脚本如下："}]},{"type":"element","tag":"blockquote","props":{},"children":[{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"The first thought is using "},{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"dfs"}]},{"type":"text","value":" search algorithm.\nAs we can use the elements of "},{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"candidates"}]},{"type":"text","value":" repetitively,\nthe children node of each node would be all element of the "},{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"candidates"}]},{"type":"text","value":".\nApplying the "},{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"dfs"}]},{"type":"text","value":" by recursively traversing."}]}]},{"type":"element","tag":"code","props":{"code":"def combinationSum(candidates: List[int], target: int) -> List[List[int]]:\n    ans = []\n\n    def dfs(candidates, t, l):\n        for c in candidates:\n            if c == t:\n                ans.append(l+[c])\n            elif c > t:\n                continue\n            else:\n                dfs(candidates, t-c, l+[c])\n\n    dfs(candidates, target, [])\n    return ans\n","language":"python"},"children":[{"type":"element","tag":"pre","props":{},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"def combinationSum(candidates: List[int], target: int) -> List[List[int]]:\n    ans = []\n\n    def dfs(candidates, t, l):\n        for c in candidates:\n            if c == t:\n                ans.append(l+[c])\n            elif c > t:\n                continue\n            else:\n                dfs(candidates, t-c, l+[c])\n\n    dfs(candidates, target, [])\n    return ans\n"}]}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"此时的结果为:"}]},{"type":"element","tag":"code","props":{"code":"print(combinationSum([2, 3, 6, 7], 7))\n[[2, 2, 3], [2, 3, 2], [3, 2, 2], [7]]\n"},"children":[{"type":"element","tag":"pre","props":{},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"print(combinationSum([2, 3, 6, 7], 7))\n[[2, 2, 3], [2, 3, 2], [3, 2, 2], [7]]\n"}]}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"并发现有重复的答案，通过观察发现有以下规律："}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"向下搜索时，总是从左端开始，也就是小的数字开始"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"重复的现象出现于：先到达值较大的节点，然后搜索值小的节点。然而这种情况必然导致重复，因为我们每次都是从值小的节点开始搜索的。"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"因此，为了去重我们需要这样做：每次到达某节点时，若该节点的值比 "},{"type":"element","tag":"em","props":{},"children":[{"type":"text","value":"遍历过的最大值"}]},{"type":"text","value":" 小，\n那么我们有理由认为这将导致重复的结果，因此只需添加一个判断即可："}]},{"type":"element","tag":"code","props":{"code":"def combinationSum(candidates: List[int], target: int) -> List[List[int]]:\n    ans = []\n\n    def dfs(candidates, t, l):\n        for c in candidates:\n            if len(l) and c < max(l):\n                continue\n            if c == t:\n                ans.append(l+[c])\n            elif c > t:\n                continue\n            else:\n                dfs(candidates, t-c, l+[c])\n\n    dfs(candidates, target, [])\n    return ans\n","highlights":[6,7],"language":"python"},"children":[{"type":"element","tag":"pre","props":{},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"def combinationSum(candidates: List[int], target: int) -> List[List[int]]:\n    ans = []\n\n    def dfs(candidates, t, l):\n        for c in candidates:\n            if len(l) and c < max(l):\n                continue\n            if c == t:\n                ans.append(l+[c])\n            elif c > t:\n                continue\n            else:\n                dfs(candidates, t-c, l+[c])\n\n    dfs(candidates, target, [])\n    return ans\n"}]}]}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[{"id":"question","depth":2,"text":"Question"},{"id":"solution","depth":2,"text":"Solution"}]}},"_type":"markdown","_id":"content:article:5.lc_39.md","_source":"content","_file":"article/5.lc_39.md","_extension":"md"},"hash":"dFbQICOBqw"}